{"ast":null,"code":"/*!\n * DrawSVGPlugin 3.12.7\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _toArray,\n    _doc,\n    _win,\n    _isEdge,\n    _coreInitted,\n    _warned,\n    _getStyleSaver,\n    _reverting,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _numExp = /[-+=\\.]*\\d+[\\.e\\-\\+]*\\d*[e\\-\\+]*\\d*/gi,\n    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n_types = {\n  rect: [\"width\", \"height\"],\n  circle: [\"r\", \"r\"],\n  ellipse: [\"rx\", \"ry\"],\n  line: [\"x2\", \"y2\"]\n},\n    _round = function _round(value) {\n  return Math.round(value * 10000) / 10000;\n},\n    _parseNum = function _parseNum(value) {\n  return parseFloat(value) || 0;\n},\n    _parseSingleVal = function _parseSingleVal(value, length) {\n  var num = _parseNum(value);\n\n  return ~value.indexOf(\"%\") ? num / 100 * length : num;\n},\n    _getAttributeAsNumber = function _getAttributeAsNumber(target, attr) {\n  return _parseNum(target.getAttribute(attr));\n},\n    _sqrt = Math.sqrt,\n    _getDistance = function _getDistance(x1, y1, x2, y2, scaleX, scaleY) {\n  return _sqrt(Math.pow((_parseNum(x2) - _parseNum(x1)) * scaleX, 2) + Math.pow((_parseNum(y2) - _parseNum(y1)) * scaleY, 2));\n},\n    _warn = function _warn(message) {\n  return console.warn(message);\n},\n    _hasNonScalingStroke = function _hasNonScalingStroke(target) {\n  return target.getAttribute(\"vector-effect\") === \"non-scaling-stroke\";\n},\n    _bonusValidated = 1,\n    //<name>DrawSVGPlugin</name>\n//accepts values like \"100%\" or \"20% 80%\" or \"20 50\" and parses it into an absolute start and end position on the line/stroke based on its length. Returns an an array with the start and end values, like [0, 243]\n_parse = function _parse(value, length, defaultStart) {\n  var i = value.indexOf(\" \"),\n      s,\n      e;\n\n  if (i < 0) {\n    s = defaultStart !== undefined ? defaultStart + \"\" : value;\n    e = value;\n  } else {\n    s = value.substr(0, i);\n    e = value.substr(i + 1);\n  }\n\n  s = _parseSingleVal(s, length);\n  e = _parseSingleVal(e, length);\n  return s > e ? [e, s] : [s, e];\n},\n    _getLength = function _getLength(target) {\n  target = _toArray(target)[0];\n\n  if (!target) {\n    return 0;\n  }\n\n  var type = target.tagName.toLowerCase(),\n      style = target.style,\n      scaleX = 1,\n      scaleY = 1,\n      length,\n      bbox,\n      points,\n      prevPoint,\n      i,\n      rx,\n      ry;\n\n  if (_hasNonScalingStroke(target)) {\n    //non-scaling-stroke basically scales the shape and then strokes it at the screen-level (after transforms), thus we need to adjust the length accordingly.\n    scaleY = target.getScreenCTM();\n    scaleX = _sqrt(scaleY.a * scaleY.a + scaleY.b * scaleY.b);\n    scaleY = _sqrt(scaleY.d * scaleY.d + scaleY.c * scaleY.c);\n  }\n\n  try {\n    //IE bug: calling <path>.getTotalLength() locks the repaint area of the stroke to whatever its current dimensions are on that frame/tick. To work around that, we must call getBBox() to force IE to recalculate things.\n    bbox = target.getBBox(); //solely for fixing bug in IE - we don't actually use the bbox.\n  } catch (e) {\n    //firefox has a bug that throws an error if the element isn't visible.\n    _warn(\"Some browsers won't measure invisible elements (like display:none or masks inside defs).\");\n  }\n\n  var _ref = bbox || {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n      x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height;\n\n  if ((!bbox || !width && !height) && _types[type]) {\n    //if the element isn't visible, try to discern width/height using its attributes.\n    width = _getAttributeAsNumber(target, _types[type][0]);\n    height = _getAttributeAsNumber(target, _types[type][1]);\n\n    if (type !== \"rect\" && type !== \"line\") {\n      //double the radius for circles and ellipses\n      width *= 2;\n      height *= 2;\n    }\n\n    if (type === \"line\") {\n      x = _getAttributeAsNumber(target, \"x1\");\n      y = _getAttributeAsNumber(target, \"y1\");\n      width = Math.abs(width - x);\n      height = Math.abs(height - y);\n    }\n  }\n\n  if (type === \"path\") {\n    prevPoint = style.strokeDasharray;\n    style.strokeDasharray = \"none\";\n    length = target.getTotalLength() || 0;\n    _round(scaleX) !== _round(scaleY) && !_warned && (_warned = 1) && _warn(\"Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled.\");\n    length *= (scaleX + scaleY) / 2;\n    style.strokeDasharray = prevPoint;\n  } else if (type === \"rect\") {\n    length = width * 2 * scaleX + height * 2 * scaleY;\n  } else if (type === \"line\") {\n    length = _getDistance(x, y, x + width, y + height, scaleX, scaleY);\n  } else if (type === \"polyline\" || type === \"polygon\") {\n    points = target.getAttribute(\"points\").match(_numExp) || [];\n    type === \"polygon\" && points.push(points[0], points[1]);\n    length = 0;\n\n    for (i = 2; i < points.length; i += 2) {\n      length += _getDistance(points[i - 2], points[i - 1], points[i], points[i + 1], scaleX, scaleY) || 0;\n    }\n  } else if (type === \"circle\" || type === \"ellipse\") {\n    rx = width / 2 * scaleX;\n    ry = height / 2 * scaleY;\n    length = Math.PI * (3 * (rx + ry) - _sqrt((3 * rx + ry) * (rx + 3 * ry)));\n  }\n\n  return length || 0;\n},\n    _getPosition = function _getPosition(target, length) {\n  target = _toArray(target)[0];\n\n  if (!target) {\n    return [0, 0];\n  }\n\n  length || (length = _getLength(target) + 1);\n\n  var cs = _win.getComputedStyle(target),\n      dash = cs.strokeDasharray || \"\",\n      offset = _parseNum(cs.strokeDashoffset),\n      i = dash.indexOf(\",\");\n\n  i < 0 && (i = dash.indexOf(\" \"));\n  dash = i < 0 ? length : _parseNum(dash.substr(0, i));\n  dash > length && (dash = length);\n  return [-offset || 0, dash - offset || 0];\n},\n    _initCore = function _initCore() {\n  if (_windowExists()) {\n    _doc = document;\n    _win = window;\n    _coreInitted = gsap = _getGSAP();\n    _toArray = gsap.utils.toArray;\n    _getStyleSaver = gsap.core.getStyleSaver;\n\n    _reverting = gsap.core.reverting || function () {};\n\n    _isEdge = ((_win.navigator || {}).userAgent || \"\").indexOf(\"Edge\") !== -1; //Microsoft Edge has a bug that causes it not to redraw the path correctly if the stroke-linecap is anything other than \"butt\" (like \"round\") and it doesn't match the stroke-linejoin. A way to trigger it is to change the stroke-miterlimit, so we'll only do that if/when we have to (to maximize performance)\n  }\n};\n\nexport var DrawSVGPlugin = {\n  version: \"3.12.7\",\n  name: \"drawSVG\",\n  register: function register(core) {\n    gsap = core;\n\n    _initCore();\n  },\n  init: function init(target, value, tween, index, targets) {\n    if (!target.getBBox) {\n      return false;\n    }\n\n    _coreInitted || _initCore();\n\n    var length = _getLength(target),\n        start,\n        end,\n        cs;\n\n    this.styles = _getStyleSaver && _getStyleSaver(target, \"strokeDashoffset,strokeDasharray,strokeMiterlimit\");\n    this.tween = tween;\n    this._style = target.style;\n    this._target = target;\n\n    if (value + \"\" === \"true\") {\n      value = \"0 100%\";\n    } else if (!value) {\n      value = \"0 0\";\n    } else if ((value + \"\").indexOf(\" \") === -1) {\n      value = \"0 \" + value;\n    }\n\n    start = _getPosition(target, length);\n    end = _parse(value, length, start[0]);\n    this._length = _round(length);\n    this._dash = _round(start[1] - start[0]); //some browsers render artifacts if dash is 0, so we use a very small number in that case.\n\n    this._offset = _round(-start[0]);\n    this._dashPT = this.add(this, \"_dash\", this._dash, _round(end[1] - end[0]), 0, 0, 0, 0, 0, 1);\n    this._offsetPT = this.add(this, \"_offset\", this._offset, _round(-end[0]), 0, 0, 0, 0, 0, 1);\n\n    if (_isEdge) {\n      //to work around a bug in Microsoft Edge, animate the stroke-miterlimit by 0.0001 just to trigger the repaint (unnecessary if it's \"round\" and stroke-linejoin is also \"round\"). Imperceptible, relatively high-performance, and effective. Another option was to set the \"d\" <path> attribute to its current value on every tick, but that seems like it'd be much less performant.\n      cs = _win.getComputedStyle(target);\n\n      if (cs.strokeLinecap !== cs.strokeLinejoin) {\n        end = _parseNum(cs.strokeMiterlimit);\n        this.add(target.style, \"strokeMiterlimit\", end, end + 0.01);\n      }\n    }\n\n    this._live = _hasNonScalingStroke(target) || ~(value + \"\").indexOf(\"live\");\n    this._nowrap = ~(value + \"\").indexOf(\"nowrap\");\n\n    this._props.push(\"drawSVG\");\n\n    return _bonusValidated;\n  },\n  render: function render(ratio, data) {\n    if (data.tween._time || !_reverting()) {\n      var pt = data._pt,\n          style = data._style,\n          length,\n          lengthRatio,\n          dash,\n          offset;\n\n      if (pt) {\n        //when the element has vector-effect=\"non-scaling-stroke\" and the SVG is resized (like on a window resize), it actually changes the length of the stroke! So we must sense that and make the proper adjustments.\n        if (data._live) {\n          length = _getLength(data._target);\n\n          if (length !== data._length) {\n            lengthRatio = length / data._length;\n            data._length = length;\n\n            if (data._offsetPT) {\n              data._offsetPT.s *= lengthRatio;\n              data._offsetPT.c *= lengthRatio;\n            }\n\n            if (data._dashPT) {\n              data._dashPT.s *= lengthRatio;\n              data._dashPT.c *= lengthRatio;\n            } else {\n              data._dash *= lengthRatio;\n            }\n          }\n        }\n\n        while (pt) {\n          pt.r(ratio, pt.d);\n          pt = pt._next;\n        }\n\n        dash = data._dash || ratio && ratio !== 1 && 0.0001 || 0; // only let it be zero if it's at the start or end of the tween.\n\n        length = data._length - dash + 0.1;\n        offset = data._offset;\n        dash && offset && dash + Math.abs(offset % data._length) > data._length - 0.2 && (offset += offset < 0 ? 0.1 : -0.1) && (length += 0.1);\n        style.strokeDashoffset = dash ? offset : offset + 0.001;\n        style.strokeDasharray = length < 0.2 ? \"none\" : dash ? dash + \"px,\" + (data._nowrap ? 999999 : length) + \"px\" : \"0px, 999999px\";\n      }\n    } else {\n      data.styles.revert();\n    }\n  },\n  getLength: _getLength,\n  getPosition: _getPosition\n};\n_getGSAP() && gsap.registerPlugin(DrawSVGPlugin);\nexport { DrawSVGPlugin as default };","map":{"version":3,"sources":["/Users/danielmarkusson/Documents/GitHub/Portfolio/node_modules/gsap/DrawSVGPlugin.js"],"names":["gsap","_toArray","_doc","_win","_isEdge","_coreInitted","_warned","_getStyleSaver","_reverting","_windowExists","window","_getGSAP","registerPlugin","_numExp","_types","rect","circle","ellipse","line","_round","value","Math","round","_parseNum","parseFloat","_parseSingleVal","length","num","indexOf","_getAttributeAsNumber","target","attr","getAttribute","_sqrt","sqrt","_getDistance","x1","y1","x2","y2","scaleX","scaleY","pow","_warn","message","console","warn","_hasNonScalingStroke","_bonusValidated","_parse","defaultStart","i","s","e","undefined","substr","_getLength","type","tagName","toLowerCase","style","bbox","points","prevPoint","rx","ry","getScreenCTM","a","b","d","c","getBBox","_ref","x","y","width","height","abs","strokeDasharray","getTotalLength","match","push","PI","_getPosition","cs","getComputedStyle","dash","offset","strokeDashoffset","_initCore","document","utils","toArray","core","getStyleSaver","reverting","navigator","userAgent","DrawSVGPlugin","version","name","register","init","tween","index","targets","start","end","styles","_style","_target","_length","_dash","_offset","_dashPT","add","_offsetPT","strokeLinecap","strokeLinejoin","strokeMiterlimit","_live","_nowrap","_props","render","ratio","data","_time","pt","_pt","lengthRatio","r","_next","revert","getLength","getPosition","default"],"mappings":"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","sourcesContent":["/*!\n * DrawSVGPlugin 3.12.7\n * https://gsap.com\n *\n * @license Copyright 2008-2025, GreenSock. All rights reserved.\n * Subject to the terms at https://gsap.com/standard-license or for\n * Club GSAP members, the agreement issued with that membership.\n * @author: Jack Doyle, jack@greensock.com\n*/\n\n/* eslint-disable */\nvar gsap,\n    _toArray,\n    _doc,\n    _win,\n    _isEdge,\n    _coreInitted,\n    _warned,\n    _getStyleSaver,\n    _reverting,\n    _windowExists = function _windowExists() {\n  return typeof window !== \"undefined\";\n},\n    _getGSAP = function _getGSAP() {\n  return gsap || _windowExists() && (gsap = window.gsap) && gsap.registerPlugin && gsap;\n},\n    _numExp = /[-+=\\.]*\\d+[\\.e\\-\\+]*\\d*[e\\-\\+]*\\d*/gi,\n    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.\n_types = {\n  rect: [\"width\", \"height\"],\n  circle: [\"r\", \"r\"],\n  ellipse: [\"rx\", \"ry\"],\n  line: [\"x2\", \"y2\"]\n},\n    _round = function _round(value) {\n  return Math.round(value * 10000) / 10000;\n},\n    _parseNum = function _parseNum(value) {\n  return parseFloat(value) || 0;\n},\n    _parseSingleVal = function _parseSingleVal(value, length) {\n  var num = _parseNum(value);\n\n  return ~value.indexOf(\"%\") ? num / 100 * length : num;\n},\n    _getAttributeAsNumber = function _getAttributeAsNumber(target, attr) {\n  return _parseNum(target.getAttribute(attr));\n},\n    _sqrt = Math.sqrt,\n    _getDistance = function _getDistance(x1, y1, x2, y2, scaleX, scaleY) {\n  return _sqrt(Math.pow((_parseNum(x2) - _parseNum(x1)) * scaleX, 2) + Math.pow((_parseNum(y2) - _parseNum(y1)) * scaleY, 2));\n},\n    _warn = function _warn(message) {\n  return console.warn(message);\n},\n    _hasNonScalingStroke = function _hasNonScalingStroke(target) {\n  return target.getAttribute(\"vector-effect\") === \"non-scaling-stroke\";\n},\n    _bonusValidated = 1,\n    //<name>DrawSVGPlugin</name>\n//accepts values like \"100%\" or \"20% 80%\" or \"20 50\" and parses it into an absolute start and end position on the line/stroke based on its length. Returns an an array with the start and end values, like [0, 243]\n_parse = function _parse(value, length, defaultStart) {\n  var i = value.indexOf(\" \"),\n      s,\n      e;\n\n  if (i < 0) {\n    s = defaultStart !== undefined ? defaultStart + \"\" : value;\n    e = value;\n  } else {\n    s = value.substr(0, i);\n    e = value.substr(i + 1);\n  }\n\n  s = _parseSingleVal(s, length);\n  e = _parseSingleVal(e, length);\n  return s > e ? [e, s] : [s, e];\n},\n    _getLength = function _getLength(target) {\n  target = _toArray(target)[0];\n\n  if (!target) {\n    return 0;\n  }\n\n  var type = target.tagName.toLowerCase(),\n      style = target.style,\n      scaleX = 1,\n      scaleY = 1,\n      length,\n      bbox,\n      points,\n      prevPoint,\n      i,\n      rx,\n      ry;\n\n  if (_hasNonScalingStroke(target)) {\n    //non-scaling-stroke basically scales the shape and then strokes it at the screen-level (after transforms), thus we need to adjust the length accordingly.\n    scaleY = target.getScreenCTM();\n    scaleX = _sqrt(scaleY.a * scaleY.a + scaleY.b * scaleY.b);\n    scaleY = _sqrt(scaleY.d * scaleY.d + scaleY.c * scaleY.c);\n  }\n\n  try {\n    //IE bug: calling <path>.getTotalLength() locks the repaint area of the stroke to whatever its current dimensions are on that frame/tick. To work around that, we must call getBBox() to force IE to recalculate things.\n    bbox = target.getBBox(); //solely for fixing bug in IE - we don't actually use the bbox.\n  } catch (e) {\n    //firefox has a bug that throws an error if the element isn't visible.\n    _warn(\"Some browsers won't measure invisible elements (like display:none or masks inside defs).\");\n  }\n\n  var _ref = bbox || {\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0\n  },\n      x = _ref.x,\n      y = _ref.y,\n      width = _ref.width,\n      height = _ref.height;\n\n  if ((!bbox || !width && !height) && _types[type]) {\n    //if the element isn't visible, try to discern width/height using its attributes.\n    width = _getAttributeAsNumber(target, _types[type][0]);\n    height = _getAttributeAsNumber(target, _types[type][1]);\n\n    if (type !== \"rect\" && type !== \"line\") {\n      //double the radius for circles and ellipses\n      width *= 2;\n      height *= 2;\n    }\n\n    if (type === \"line\") {\n      x = _getAttributeAsNumber(target, \"x1\");\n      y = _getAttributeAsNumber(target, \"y1\");\n      width = Math.abs(width - x);\n      height = Math.abs(height - y);\n    }\n  }\n\n  if (type === \"path\") {\n    prevPoint = style.strokeDasharray;\n    style.strokeDasharray = \"none\";\n    length = target.getTotalLength() || 0;\n    _round(scaleX) !== _round(scaleY) && !_warned && (_warned = 1) && _warn(\"Warning: <path> length cannot be measured when vector-effect is non-scaling-stroke and the element isn't proportionally scaled.\");\n    length *= (scaleX + scaleY) / 2;\n    style.strokeDasharray = prevPoint;\n  } else if (type === \"rect\") {\n    length = width * 2 * scaleX + height * 2 * scaleY;\n  } else if (type === \"line\") {\n    length = _getDistance(x, y, x + width, y + height, scaleX, scaleY);\n  } else if (type === \"polyline\" || type === \"polygon\") {\n    points = target.getAttribute(\"points\").match(_numExp) || [];\n    type === \"polygon\" && points.push(points[0], points[1]);\n    length = 0;\n\n    for (i = 2; i < points.length; i += 2) {\n      length += _getDistance(points[i - 2], points[i - 1], points[i], points[i + 1], scaleX, scaleY) || 0;\n    }\n  } else if (type === \"circle\" || type === \"ellipse\") {\n    rx = width / 2 * scaleX;\n    ry = height / 2 * scaleY;\n    length = Math.PI * (3 * (rx + ry) - _sqrt((3 * rx + ry) * (rx + 3 * ry)));\n  }\n\n  return length || 0;\n},\n    _getPosition = function _getPosition(target, length) {\n  target = _toArray(target)[0];\n\n  if (!target) {\n    return [0, 0];\n  }\n\n  length || (length = _getLength(target) + 1);\n\n  var cs = _win.getComputedStyle(target),\n      dash = cs.strokeDasharray || \"\",\n      offset = _parseNum(cs.strokeDashoffset),\n      i = dash.indexOf(\",\");\n\n  i < 0 && (i = dash.indexOf(\" \"));\n  dash = i < 0 ? length : _parseNum(dash.substr(0, i));\n  dash > length && (dash = length);\n  return [-offset || 0, dash - offset || 0];\n},\n    _initCore = function _initCore() {\n  if (_windowExists()) {\n    _doc = document;\n    _win = window;\n    _coreInitted = gsap = _getGSAP();\n    _toArray = gsap.utils.toArray;\n    _getStyleSaver = gsap.core.getStyleSaver;\n\n    _reverting = gsap.core.reverting || function () {};\n\n    _isEdge = ((_win.navigator || {}).userAgent || \"\").indexOf(\"Edge\") !== -1; //Microsoft Edge has a bug that causes it not to redraw the path correctly if the stroke-linecap is anything other than \"butt\" (like \"round\") and it doesn't match the stroke-linejoin. A way to trigger it is to change the stroke-miterlimit, so we'll only do that if/when we have to (to maximize performance)\n  }\n};\n\nexport var DrawSVGPlugin = {\n  version: \"3.12.7\",\n  name: \"drawSVG\",\n  register: function register(core) {\n    gsap = core;\n\n    _initCore();\n  },\n  init: function init(target, value, tween, index, targets) {\n    if (!target.getBBox) {\n      return false;\n    }\n\n    _coreInitted || _initCore();\n\n    var length = _getLength(target),\n        start,\n        end,\n        cs;\n\n    this.styles = _getStyleSaver && _getStyleSaver(target, \"strokeDashoffset,strokeDasharray,strokeMiterlimit\");\n    this.tween = tween;\n    this._style = target.style;\n    this._target = target;\n\n    if (value + \"\" === \"true\") {\n      value = \"0 100%\";\n    } else if (!value) {\n      value = \"0 0\";\n    } else if ((value + \"\").indexOf(\" \") === -1) {\n      value = \"0 \" + value;\n    }\n\n    start = _getPosition(target, length);\n    end = _parse(value, length, start[0]);\n    this._length = _round(length);\n    this._dash = _round(start[1] - start[0]); //some browsers render artifacts if dash is 0, so we use a very small number in that case.\n\n    this._offset = _round(-start[0]);\n    this._dashPT = this.add(this, \"_dash\", this._dash, _round(end[1] - end[0]), 0, 0, 0, 0, 0, 1);\n    this._offsetPT = this.add(this, \"_offset\", this._offset, _round(-end[0]), 0, 0, 0, 0, 0, 1);\n\n    if (_isEdge) {\n      //to work around a bug in Microsoft Edge, animate the stroke-miterlimit by 0.0001 just to trigger the repaint (unnecessary if it's \"round\" and stroke-linejoin is also \"round\"). Imperceptible, relatively high-performance, and effective. Another option was to set the \"d\" <path> attribute to its current value on every tick, but that seems like it'd be much less performant.\n      cs = _win.getComputedStyle(target);\n\n      if (cs.strokeLinecap !== cs.strokeLinejoin) {\n        end = _parseNum(cs.strokeMiterlimit);\n        this.add(target.style, \"strokeMiterlimit\", end, end + 0.01);\n      }\n    }\n\n    this._live = _hasNonScalingStroke(target) || ~(value + \"\").indexOf(\"live\");\n    this._nowrap = ~(value + \"\").indexOf(\"nowrap\");\n\n    this._props.push(\"drawSVG\");\n\n    return _bonusValidated;\n  },\n  render: function render(ratio, data) {\n    if (data.tween._time || !_reverting()) {\n      var pt = data._pt,\n          style = data._style,\n          length,\n          lengthRatio,\n          dash,\n          offset;\n\n      if (pt) {\n        //when the element has vector-effect=\"non-scaling-stroke\" and the SVG is resized (like on a window resize), it actually changes the length of the stroke! So we must sense that and make the proper adjustments.\n        if (data._live) {\n          length = _getLength(data._target);\n\n          if (length !== data._length) {\n            lengthRatio = length / data._length;\n            data._length = length;\n\n            if (data._offsetPT) {\n              data._offsetPT.s *= lengthRatio;\n              data._offsetPT.c *= lengthRatio;\n            }\n\n            if (data._dashPT) {\n              data._dashPT.s *= lengthRatio;\n              data._dashPT.c *= lengthRatio;\n            } else {\n              data._dash *= lengthRatio;\n            }\n          }\n        }\n\n        while (pt) {\n          pt.r(ratio, pt.d);\n          pt = pt._next;\n        }\n\n        dash = data._dash || ratio && ratio !== 1 && 0.0001 || 0; // only let it be zero if it's at the start or end of the tween.\n\n        length = data._length - dash + 0.1;\n        offset = data._offset;\n        dash && offset && dash + Math.abs(offset % data._length) > data._length - 0.2 && (offset += offset < 0 ? 0.1 : -0.1) && (length += 0.1);\n        style.strokeDashoffset = dash ? offset : offset + 0.001;\n        style.strokeDasharray = length < 0.2 ? \"none\" : dash ? dash + \"px,\" + (data._nowrap ? 999999 : length) + \"px\" : \"0px, 999999px\";\n      }\n    } else {\n      data.styles.revert();\n    }\n  },\n  getLength: _getLength,\n  getPosition: _getPosition\n};\n_getGSAP() && gsap.registerPlugin(DrawSVGPlugin);\nexport { DrawSVGPlugin as default };"]},"metadata":{},"sourceType":"module"}